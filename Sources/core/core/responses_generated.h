// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_RESPONSES_GOODAI_ARNOLD_NETWORK_H_
#define FLATBUFFERS_GENERATED_RESPONSES_GOODAI_ARNOLD_NETWORK_H_

#include "flatbuffers/flatbuffers.h"


namespace GoodAI {
namespace Arnold {
namespace Network {

struct ErrorResponse;
struct StateResponse;
struct ResponseMessage;

enum StateType {
  StateType_Empty = 0,
  StateType_Running = 1,
  StateType_Paused = 2,
  StateType_ShuttingDown = 3,
  StateType_Invalid = 4,
  StateType_MIN = StateType_Empty,
  StateType_MAX = StateType_Invalid
};

inline const char **EnumNamesStateType() {
  static const char *names[] = { "Empty", "Running", "Paused", "ShuttingDown", "Invalid", nullptr };
  return names;
}

inline const char *EnumNameStateType(StateType e) { return EnumNamesStateType()[static_cast<int>(e)]; }

enum Response {
  Response_NONE = 0,
  Response_ErrorResponse = 1,
  Response_StateResponse = 2,
  Response_MIN = Response_NONE,
  Response_MAX = Response_StateResponse
};

inline const char **EnumNamesResponse() {
  static const char *names[] = { "NONE", "ErrorResponse", "StateResponse", nullptr };
  return names;
}

inline const char *EnumNameResponse(Response e) { return EnumNamesResponse()[static_cast<int>(e)]; }

inline bool VerifyResponse(flatbuffers::Verifier &verifier, const void *union_obj, Response type);

struct ErrorResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const { return GetPointer<const flatbuffers::String *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct ErrorResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) { fbb_.AddOffset(ErrorResponse::VT_MESSAGE, message); }
  ErrorResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ErrorResponseBuilder &operator=(const ErrorResponseBuilder &);
  flatbuffers::Offset<ErrorResponse> Finish() {
    auto o = flatbuffers::Offset<ErrorResponse>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ErrorResponse> CreateErrorResponse(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct StateResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATE = 4
  };
  StateType state() const { return static_cast<StateType>(GetField<int8_t>(VT_STATE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct StateResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(StateType state) { fbb_.AddElement<int8_t>(StateResponse::VT_STATE, static_cast<int8_t>(state), 0); }
  StateResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StateResponseBuilder &operator=(const StateResponseBuilder &);
  flatbuffers::Offset<StateResponse> Finish() {
    auto o = flatbuffers::Offset<StateResponse>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<StateResponse> CreateStateResponse(flatbuffers::FlatBufferBuilder &_fbb,
   StateType state = StateType_Empty) {
  StateResponseBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct ResponseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  Response response_type() const { return static_cast<Response>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0)); }
  const void *response() const { return GetPointer<const void *>(VT_RESPONSE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RESPONSE) &&
           VerifyResponse(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

struct ResponseMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response_type(Response response_type) { fbb_.AddElement<uint8_t>(ResponseMessage::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0); }
  void add_response(flatbuffers::Offset<void> response) { fbb_.AddOffset(ResponseMessage::VT_RESPONSE, response); }
  ResponseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ResponseMessageBuilder &operator=(const ResponseMessageBuilder &);
  flatbuffers::Offset<ResponseMessage> Finish() {
    auto o = flatbuffers::Offset<ResponseMessage>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ResponseMessage> CreateResponseMessage(flatbuffers::FlatBufferBuilder &_fbb,
   Response response_type = Response_NONE,
   flatbuffers::Offset<void> response = 0) {
  ResponseMessageBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

inline bool VerifyResponse(flatbuffers::Verifier &verifier, const void *union_obj, Response type) {
  switch (type) {
    case Response_NONE: return true;
    case Response_ErrorResponse: return verifier.VerifyTable(reinterpret_cast<const ErrorResponse *>(union_obj));
    case Response_StateResponse: return verifier.VerifyTable(reinterpret_cast<const StateResponse *>(union_obj));
    default: return false;
  }
}

inline const GoodAI::Arnold::Network::ResponseMessage *GetResponseMessage(const void *buf) { return flatbuffers::GetRoot<GoodAI::Arnold::Network::ResponseMessage>(buf); }

inline bool VerifyResponseMessageBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<GoodAI::Arnold::Network::ResponseMessage>(); }

inline void FinishResponseMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<GoodAI::Arnold::Network::ResponseMessage> root) { fbb.Finish(root); }

}  // namespace Network
}  // namespace Arnold
}  // namespace GoodAI

#endif  // FLATBUFFERS_GENERATED_RESPONSES_GOODAI_ARNOLD_NETWORK_H_
